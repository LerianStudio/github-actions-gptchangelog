name: Generate Changelog
description: Generate changelog and release notes using gptchangelog

inputs:
  OPENAI_API_KEY:
    required: true
  GH_TOKEN:
    required: true
  LERIAN_CI_CD_USER_GPG_KEY:
    required: true
  LERIAN_CI_CD_USER_GPG_KEY_PASSWORD:
    required: true
  LERIAN_CI_CD_USER_NAME:
    required: true
  LERIAN_CI_CD_USER_EMAIL:
    required: true
  LERIAN_STUDIO_MIDAZ_PUSH_BOT_APP_ID:
    required: true
  LERIAN_STUDIO_MIDAZ_PUSH_BOT_PRIVATE_KEY:
    required: true

permission:
  contents: read
  id-token: write
  packages: write

runs:
  using: "composite"
  steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - run: |
        python -m pip install --upgrade pip
        pip install gptchangelog
      shell: bash

    - run: |
        mkdir -p .gptchangelog
        echo "[gptchangelog]" > .gptchangelog/config.ini
        echo "openai = true" >> .gptchangelog/config.ini
        echo "[openai]" >> .gptchangelog/config.ini
        echo "api_key = ${OPENAI_API_KEY}" >> .gptchangelog/config.ini
        echo "model = gpt-4o" >> .gptchangelog/config.ini
        echo "max_context_tokens = 80000" >> .gptchangelog/config.ini
      shell: bash
      env:
        OPENAI_API_KEY: ${{ inputs.OPENAI_API_KEY }}

    - run: |
        mkdir -p .gptchangelog/templates
        cat > .gptchangelog/templates/changelog_prompt.txt << 'EOF'
        # $project_name Changelog

        ## Release $next_version (Released on $current_date)

        ### What's New
        $commit_messages

        ### ‚ú® Features
        - Highlight new features added in this release.

        ### üõ† Fixes
        - List bug fixes and improvements.

        ### üìö Documentation
        - Summarize updates to documentation.

        ### üöÄ Improvements
        - Highlight performance or backend optimizations.

        ### ‚ö†Ô∏è Breaking Changes
        - List any breaking changes here.

        ### üôå Contributors
        - Acknowledge contributors for this release.
        EOF
      shell: bash

    - run: |
        echo "OPENAI_API_KEY=${OPENAI_API_KEY}" > .env
        git fetch --tags

        if git describe --tags --abbrev=0 --match "v*" HEAD >/dev/null 2>&1; then
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*" HEAD)

          if git describe --tags --abbrev=0 --match "v*" HEAD^ >/dev/null 2>&1; then
            PENULT_TAG=$(git describe --tags --abbrev=0 --match "v*" HEAD^)
            echo "üü¢ Gerando changelog de $PENULT_TAG at√© $LAST_TAG"
            gptchangelog generate --since "$PENULT_TAG" --to "$LAST_TAG" --output CHANGELOG.md
          else
            FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
            echo "üü° Primeira tag detectada. Gerando changelog de $FIRST_COMMIT at√© $LAST_TAG"
            gptchangelog generate --since "$FIRST_COMMIT" --to "$LAST_TAG" --output CHANGELOG.md
          fi

          # Exportando LAST_TAG para o ambiente
          echo "LAST_TAG=$LAST_TAG" >> $GITHUB_ENV
        else
          FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
          echo "üî¥ Nenhuma tag detectada. Gerando changelog de $FIRST_COMMIT at√© HEAD"
          gptchangelog generate --since "$FIRST_COMMIT" --to HEAD --output CHANGELOG.md
          
          # Fallback para LAST_TAG
          echo "LAST_TAG=HEAD" >> $GITHUB_ENV
        fi
      
        echo "üßπ Limpando blocos de markdown extras"
        sed -i '/^```/d' CHANGELOG.md
      shell: bash
      env:
        OPENAI_API_KEY: ${{ inputs.OPENAI_API_KEY }}
      
    - name: Substituir cabe√ßalho da vers√£o
      run: |
        echo "üìå Substituindo cabe√ßalho da vers√£o gerado pelo gptchangelog"

        # Encontra a linha que cont√©m o primeiro cabe√ßalho de vers√£o `## [vX.Y.Z] - ...`
        HEADER_LINE=$(grep -nE "^## \[v[0-9]+\.[0-9]+\.[0-9]+\] - " CHANGELOG.md | head -n 1 | cut -d: -f1)
        echo "üìç Cabe√ßalho encontrado na linha: $HEADER_LINE"

        # Substitui exatamente essa linha com a nova vers√£o baseada no LAST_TAG
        sed -i "${HEADER_LINE}s|^.*|## [v${LAST_TAG//v/}] - $(date +%Y-%m-%d)|" CHANGELOG.md

        echo "‚úÖ Linha atualizada:"
        sed -n "${HEADER_LINE}p" CHANGELOG.md
      shell: bash
      env:
        LAST_TAG: ${{ env.LAST_TAG }}
    
    # - name: Substituir cabe√ßalho da vers√£o
    #   run: |
    #     echo "üìå Substituindo cabe√ßalho da vers√£o"
    #     sed -i "/^## \[v[0-9]\+\.[0-9]\+\.[0-9]\+\(-[a-zA-Z0-9.]\+\)\?\] - .*/c\## [v${LAST_TAG//v/}] - $(date +%Y-%m-%d)" CHANGELOG.md
    #     cat CHANGELOG.md
    #   shell: bash
    #   env:
    #     LAST_TAG: ${{ env.LAST_TAG }}

    - name: Substituir cabe√ßalho da vers√£o
      run: |
        echo "üìå Substituindo cabe√ßalho da vers√£o"
        sed -i "5s|^## \[v[0-9]\+\.[0-9]\+\.[0-9]\+\(-[a-zA-Z0-9.]\+\)\?\] - .*|## [v${LAST_TAG//v/}] - $(date +%Y-%m-%d)|" CHANGELOG.md
        cat CHANGELOG.md
      shell: bash
      env:
        LAST_TAG: ${{ env.LAST_TAG }}
    
    - run: |
        echo "OPENAI_API_KEY=${OPENAI_API_KEY}" > .env
        git fetch --tags

        # Verifica se existe ao menos uma tag
        if git describe --tags --abbrev=0 --match "v*" HEAD >/dev/null 2>&1; then
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*" HEAD)

          # Tenta obter a tag anterior
          if git describe --tags --abbrev=0 --match "v*" HEAD^ >/dev/null 2>&1; then
            PENULT_TAG=$(git describe --tags --abbrev=0 --match "v*" HEAD^)
            echo "üü¢ Gerando release notes de $PENULT_TAG at√© $LAST_TAG"
            gptchangelog generate --since "$PENULT_TAG" --to "$LAST_TAG" --output RELEASE_NOTES.md
          else
            FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
            echo "üü° Primeira tag detectada. Gerando release notes de $FIRST_COMMIT at√© $LAST_TAG"
            gptchangelog generate --since "$FIRST_COMMIT" --to "$LAST_TAG" --output RELEASE_NOTES.md
          fi

          echo "LAST_TAG=$LAST_TAG" >> $GITHUB_ENV
        else
          FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
          echo "üî¥ Nenhuma tag detectada. Gerando release notes de $FIRST_COMMIT at√© HEAD"
          gptchangelog generate --since "$FIRST_COMMIT" --to HEAD --output RELEASE_NOTES.md
        fi
      shell: bash
      env:
        OPENAI_API_KEY: ${{ inputs.OPENAI_API_KEY }}
      
   
    - run: |
        # Captura a linha do cabe√ßalho da vers√£o
        HEADER_LINE=$(grep -n "^## \[v\?[0-9]\+\.[0-9]\+\.[0-9]\+\(-[a-zA-Z0-9.]\+\)\?\] - [0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}" RELEASE_NOTES.md | head -n1 | cut -d: -f1)

        # Verifica se a linha foi encontrada
        if [ -z "$HEADER_LINE" ]; then
          echo "Erro: n√£o foi poss√≠vel encontrar o cabe√ßalho da vers√£o em RELEASE_NOTES.md"
          exit 1
        fi

        # Exibe o n√∫mero da linha onde o cabe√ßalho da vers√£o foi encontrado
        echo "üìå A linha do cabe√ßalho da vers√£o √©: $HEADER_LINE"

        # Substitui o cabe√ßalho da vers√£o (com ou sem 'v' no original)
        sed -i "${HEADER_LINE}s|^## \[v\?[0-9]\+\.[0-9]\+\.[0-9]\+\(-[a-zA-Z0-9.]\+\)\?\] - .*|## [v${LAST_TAG//v/}] - $(date +%Y-%m-%d)|" RELEASE_NOTES.md

        # Exibe o arquivo para confirma√ß√£o
        cat RELEASE_NOTES.md
      shell: bash
      env:
        LAST_TAG: ${{ env.LAST_TAG }}
      
    - run: |
        gh release edit ${{ env.LAST_TAG }} --notes-file RELEASE_NOTES.md
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.GH_TOKEN }}

    - uses: crazy-max/ghaction-import-gpg@v6
      with:
        gpg_private_key: ${{ inputs.LERIAN_CI_CD_USER_GPG_KEY }}
        passphrase: ${{ inputs.LERIAN_CI_CD_USER_GPG_KEY_PASSWORD }}
        git_committer_name: ${{ inputs.LERIAN_CI_CD_USER_NAME }}
        git_committer_email: ${{ inputs.LERIAN_CI_CD_USER_EMAIL }}
        git_config_global: true
        git_user_signingkey: true
        git_commit_gpgsign: true

    - uses: actions/create-github-app-token@v1
      id: app-token
      with:
        app-id: ${{ inputs.LERIAN_STUDIO_MIDAZ_PUSH_BOT_APP_ID }}
        private-key: ${{ inputs.LERIAN_STUDIO_MIDAZ_PUSH_BOT_PRIVATE_KEY }}
    
    - run: |
        BRANCH_NAME="release/update-changelog-${{ env.LAST_TAG }}"
        git checkout -b $BRANCH_NAME

        git add CHANGELOG.md
        git diff --cached --quiet || git commit -S -m "chore(release): Update CHANGELOG"

        # Faz o merge da develop na sua branch, sempre priorizando sua vers√£o do changelog
        git fetch origin develop
        git merge -X ours origin/develop --no-ff -m "Merge develop into ${BRANCH_NAME}" || {
          # Se houver conflito no merge (ex: ort n√£o resolve tudo), for√ßa a resolu√ß√£o
          git checkout --ours CHANGELOG.md
          git add CHANGELOG.md
          git commit -m "resolve conflict using ours strategy"
        }

        # Faz o push da branch atualizada
        git push --force-with-lease origin $BRANCH_NAME

        gh pr create \
          --title "chore(release): Update CHANGELOG" \
          --body "Atualiza√ß√£o autom√°tica do changelog para ${{ env.LAST_TAG }}" \
          --base develop \
          --head $BRANCH_NAME

        gh pr merge --merge --delete-branch
      env:
        GH_TOKEN: ${{ steps.app-token.outputs.token }}
      shell: bash
