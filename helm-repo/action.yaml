name: Generate Changelog
description: Generate changelog zusing gptchangelog

inputs:
  OPENAI_API_KEY:
    required: true
  GH_TOKEN:
    required: true
  LERIAN_CI_CD_USER_GPG_KEY:
    required: true
  LERIAN_CI_CD_USER_GPG_KEY_PASSWORD:
    required: true
  LERIAN_CI_CD_USER_NAME:
    required: true
  LERIAN_CI_CD_USER_EMAIL:
    required: true
  LERIAN_STUDIO_MIDAZ_PUSH_BOT_APP_ID:
    required: true
  LERIAN_STUDIO_MIDAZ_PUSH_BOT_PRIVATE_KEY:
    required: true
  WORK_DIR:
    required: false
    default: '.'

  TAG_PREFIX:
    description: 'An optional prefix for git tags. If not set, it is derived from WORK_DIR.'
    required: false

permission:
  contents: write
  id-token: write
  packages: write

runs:
  using: "composite"
  steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - run: |
        python -m pip install --upgrade pip
        pip install gptchangelog
      shell: bash

    - run: |
        mkdir -p .gptchangelog
        echo "[gptchangelog]" > .gptchangelog/config.ini
        echo "openai = true" >> .gptchangelog/config.ini
        echo "[openai]" >> .gptchangelog/config.ini
        echo "api_key = ${OPENAI_API_KEY}" >> .gptchangelog/config.ini
        echo "model = gpt-4o" >> .gptchangelog/config.ini
        echo "max_context_tokens = 80000" >> .gptchangelog/config.ini
      shell: bash
      env:
        OPENAI_API_KEY: ${{ inputs.OPENAI_API_KEY }}

    - run: |
        mkdir -p .gptchangelog/templates
        cat > .gptchangelog/templates/changelog_prompt.txt << 'EOF'
        # $project_name Changelog

        ## Release $next_version (Released on $current_date)

        ### What's New
        $commit_messages

        ### ‚ú® Features
        - Highlight new features added in this release.

        ### üõ† Fixes
        - List bug fixes and improvements.

        ### üìö Documentation
        - Summarize updates to documentation.

        ### üöÄ Improvements
        - Highlight performance or backend optimizations.

        ### ‚ö†Ô∏è Breaking Changes
        - List any breaking changes here.

        ### üôå Contributors
        - Acknowledge contributors for this release.
        EOF
      shell: bash

    - name: Set changelog target path
      id: changelog_path_setter
      shell: bash
      env:
        WORK_DIR_INPUT: ${{ inputs.WORK_DIR }}
      run: |
        CHANGELOG_FILE_NAME="CHANGELOG.md"
        FINAL_PATH=""
        if [ -n "$WORK_DIR_INPUT" ] && [ "$WORK_DIR_INPUT" != "." ]; then
          # WORK_DIR is specified and is not just '.'
          FINAL_PATH="${WORK_DIR_INPUT}/${CHANGELOG_FILE_NAME}"
          echo "INFO: WORK_DIR ('$WORK_DIR_INPUT') is set. CHANGELOG.md path: $FINAL_PATH"
        else
          # WORK_DIR is empty or '.', use current directory
          FINAL_PATH="./${CHANGELOG_FILE_NAME}"
          echo "INFO: WORK_DIR is empty or '.'. CHANGELOG.md path: $FINAL_PATH"
        fi
        echo "path=$FINAL_PATH" >> "$GITHUB_OUTPUT"

    - run: |
        echo "OPENAI_API_KEY=${OPENAI_API_KEY}" > .env
        git fetch --tags

        if [ -n "${TAG_PREFIX}" ]; then
          PREFIX="${TAG_PREFIX}"
          echo "INFO: Using provided TAG_PREFIX: $PREFIX"
        else
          PREFIX="$(basename "$WORK_DIR")-"
          echo "INFO: Deriving tag prefix from WORK_DIR: $PREFIX"
        fi

        TAGS=($(git for-each-ref --sort=-creatordate --format='%(refname:short)' "refs/tags/${PREFIX}*"))

        if [ ${#TAGS[@]} -ge 1 ]; then
          LAST_TAG=${TAGS[0]}
          echo "üîñ LAST_TAG: $LAST_TAG"
          PENULT_TAG=""

          if [ ${#TAGS[@]} -ge 2 ]; then
            # If LAST_TAG is a stable release (e.g., v1.2.3), find the previous stable release.
            if [[ "$LAST_TAG" != *-* ]]; then
              echo "üîç LAST_TAG is a stable release. Finding previous stable release."
              # Iterate through the rest of the tags to find the next stable one.
              for i in $(seq 1 $((${#TAGS[@]} - 1))); do
                CANDIDATE_TAG=${TAGS[$i]}
                if [[ "$CANDIDATE_TAG" != *-* ]]; then
                  PENULT_TAG=$CANDIDATE_TAG
                  break # Found it
                fi
              done
            else
              # If LAST_TAG is a pre-release (e.g., v1.2.3-beta.1), use the chronologically previous tag.
              echo "üîç LAST_TAG is a pre-release. Using the chronologically previous tag."
              PENULT_TAG=${TAGS[1]}
            fi
          fi

          if [ -n "$PENULT_TAG" ]; then
            echo "üü¢ Generating changelog from $PENULT_TAG to $LAST_TAG"
            gptchangelog generate --since "$PENULT_TAG" --to "$LAST_TAG" --output "$CHANGELOG_TARGET_PATH"
          else
            # Fallback for the very first tag or if no suitable previous tag was found.
            FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
            echo "üü° No suitable previous tag found. Generating changelog from $FIRST_COMMIT to $LAST_TAG"
            gptchangelog generate --since "$FIRST_COMMIT" --to "$LAST_TAG" --output "$CHANGELOG_TARGET_PATH"
          fi

          echo "LAST_TAG=$LAST_TAG" >> $GITHUB_ENV
        else
          # This block handles the case where no tags with the given prefix are found at all.
          FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
          echo "üî¥ No tag found with prefix '${PREFIX}'. Generating changelog from $FIRST_COMMIT to HEAD"
          gptchangelog generate --since "$FIRST_COMMIT" --to HEAD --output "$CHANGELOG_TARGET_PATH"
          echo "LAST_TAG=HEAD" >> $GITHUB_ENV
        fi

        echo "üßπ Cleaning markdown extra blocks"
        sed -i '/^```/d' "$CHANGELOG_TARGET_PATH"
      shell: bash
      env:
        OPENAI_API_KEY: ${{ inputs.OPENAI_API_KEY }}
        CHANGELOG_TARGET_PATH: ${{ steps.changelog_path_setter.outputs.path }}
        WORK_DIR: ${{ inputs.WORK_DIR }}
        TAG_PREFIX: ${{ inputs.TAG_PREFIX }}

    - name: Check for empty changelog
      id: check_changelog
      run: |
        if [ -s "$CHANGELOG_TARGET_PATH" ] && ! grep -q "No commits found" "$CHANGELOG_TARGET_PATH" && ! grep -q "No changes" "$CHANGELOG_TARGET_PATH"; then
          echo "changelog_generated=true" >> $GITHUB_OUTPUT
        else
          echo "changelog_generated=false" >> $GITHUB_OUTPUT
          echo "Changelog is empty or contains no new commits. Skipping further steps."
        fi
      shell: bash
      env:
        CHANGELOG_TARGET_PATH: ${{ steps.changelog_path_setter.outputs.path }}

    - name: Replace version header
      if: steps.check_changelog.outputs.changelog_generated == 'true'
      run: |
        if [ "${LAST_TAG}" == "HEAD" ]; then
          echo "LAST_TAG is HEAD, skipping version header replacement."
          exit 0
        fi
        echo "üìå Replacing version header"
        # Find the line with the version header, allowing for an optional 'v' prefix
        HEADER_LINE=$(grep -nE "^## \[(v)?[0-9]+\.[0-9]+\.[0-9]+.*] - " $CHANGELOG_TARGET_PATH | head -n 1 | cut -d: -f1)
        
        if [ -n "$HEADER_LINE" ]; then
          echo "üìç Header found on line: $HEADER_LINE"
          # Replace the found line with a header that does not have a 'v' prefix
          sed -i "${HEADER_LINE}s|^.*|## [${LAST_TAG//v/}] - $(date +%Y-%m-%d)|" $CHANGELOG_TARGET_PATH
          echo "‚úÖ Header updated:"
          sed -n "${HEADER_LINE}p" $CHANGELOG_TARGET_PATH
        else
          echo "‚ö†Ô∏è Could not find version header to replace."
          exit 1
        fi
      shell: bash
      env:
        LAST_TAG: ${{ env.LAST_TAG }}
        CHANGELOG_TARGET_PATH: ${{ steps.changelog_path_setter.outputs.path }}

    - uses: crazy-max/ghaction-import-gpg@v6
      if: steps.check_changelog.outputs.changelog_generated == 'true'
      with:
        gpg_private_key: ${{ inputs.LERIAN_CI_CD_USER_GPG_KEY }}
        passphrase: ${{ inputs.LERIAN_CI_CD_USER_GPG_KEY_PASSWORD }}
        git_committer_name: ${{ inputs.LERIAN_CI_CD_USER_NAME }}
        git_committer_email: ${{ inputs.LERIAN_CI_CD_USER_EMAIL }}
        git_config_global: true
        git_user_signingkey: true
        git_commit_gpgsign: true

    - uses: actions/create-github-app-token@v1
      if: steps.check_changelog.outputs.changelog_generated == 'true'
      id: app-token
      with:
        app-id: ${{ inputs.LERIAN_STUDIO_MIDAZ_PUSH_BOT_APP_ID }}
        private-key: ${{ inputs.LERIAN_STUDIO_MIDAZ_PUSH_BOT_PRIVATE_KEY }}

    - name: Create Changelog PR
      if: steps.check_changelog.outputs.changelog_generated == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ steps.app-token.outputs.token }}
        CHANGELOG_TARGET_PATH: ${{ steps.changelog_path_setter.outputs.path }}
        LAST_TAG: ${{ env.LAST_TAG }}
        WORK_DIR: ${{ inputs.WORK_DIR }}
      run: |
        BASE_BRANCH="${GITHUB_REF##*/}"
        BRANCH_NAME="release/update-changelog-${LAST_TAG}"
        COMMIT_MESSAGE="$WORK_DIR: Update CHANGELOG for $LAST_TAG"

        git checkout -b $BRANCH_NAME

        git add $CHANGELOG_TARGET_PATH
        git diff --cached --quiet || git commit -S -m "$COMMIT_MESSAGE"

        # Merge from base branch to incorporate other changes, keeping our changelog
        git fetch origin "$BASE_BRANCH"
        git merge -X ours "origin/$BASE_BRANCH" --no-ff -m "Merge branch '$BASE_BRANCH' into $BRANCH_NAME" || {
          echo "Merge failed, attempting to resolve conflicts by keeping our changelog."
          git checkout --ours "$CHANGELOG_TARGET_PATH"
          git add "$CHANGELOG_TARGET_PATH"
          git commit --no-edit
        }

        git push --force-with-lease origin "$BRANCH_NAME"

        # Check if a PR already exists and create one if it doesn't
        if ! gh pr list --head "$BRANCH_NAME" --base "$BASE_BRANCH" --json number | grep -q 'number'; then
          echo "Creating new PR for branch $BRANCH_NAME."
          gh pr create --base "$BASE_BRANCH" --head "$BRANCH_NAME" --title "$COMMIT_MESSAGE" --body "Automated changelog update for version ${LAST_TAG}."
        else
          echo "PR already exists for branch $BRANCH_NAME."
        fi
